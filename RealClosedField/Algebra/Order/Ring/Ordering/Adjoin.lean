/-
Copyright (c) 2024 Florent Schaffhauser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Florent Schaffhauser, Artie Khovanov
-/
import Mathlib.Order.Zorn
import RealClosedField.Algebra.Order.Ring.Ordering.Basic

/-!

Let `R` be a commutative ring, and let `P` be a preordering on `R`.

## Main results

* `Subsemiring.IsPreordering.exists_le`: if `a ∉ P`, then `P` extends to a preordering
containing either `a` or `-a`.
* `Subsemiring.IsPreordering.exists_le_isOrdering`: `P` extends to an ordering.
* `Subsemiring.maximal_isPreordering_iff_maximal_isOrdering`:
an ordering is maximal as an ordering if and only if it is maximal as a preordering.
* `Subsemiring.maximal_isPreordering_iff_isOrdering`: over a field,
orderings are precisely maximal preorderings.

## References

- *An introduction to real algebra*, by T.Y. Lam. Rocky Mountain J. Math. 14(4): 767-814 (1984).
[lam_1984](https://doi.org/10.1216/RMJ-1984-14-4-767)

-/

variable {R : Type*} [CommRing R]

namespace Subsemiring.IsPreordering

variable (P : Subsemiring R) [P.IsPreordering] (a : R)

/-
### Sufficient conditions for adjoining an element to a preordering
-/

variable {P a} in
theorem closure_insert (hx : -1 ∉ closure (insert a P)) :
    (closure (insert a P)).IsPreordering := .of_le (P := P) (fun _ ↦ by aesop) hx

variable {P a} in
theorem mem_closure_insert {x} :
    x ∈ closure (insert a P) ↔ ∃ y ∈ P, ∃ z ∈ P, x = y + a * z where
  mp hx := by
    induction hx using Subsemiring.closure_induction with
    | mem x hx => cases hx
                  · exact ⟨0, by aesop, 1, by aesop, by simp_all⟩
                  · exact ⟨x, ‹_›, 0, by aesop, by simp⟩
    | zero => exact ⟨0, by aesop, 0, by aesop, by simp⟩
    | one => exact ⟨1, by aesop, 0, by aesop, by simp⟩
    | add _ _ _ _ ha hb =>
      rcases ha, hb with ⟨⟨x₁, hx₁, y₁, hy₁, rfl⟩, ⟨x₂, hx₂, y₂, hy₂, rfl⟩⟩
      exact ⟨x₁ + x₂, by aesop, y₁ + y₂, by aesop, by linear_combination⟩
    | mul _ _ _ _ ha hb =>
      rcases ha, hb with ⟨⟨x₁, hx₁, y₁, hy₁, rfl⟩, ⟨x₂, hx₂, y₂, hy₂, rfl⟩⟩
      exact ⟨x₁ * x₂ + (a * a) * (y₁ * y₂), by aesop, x₁ * y₂ + y₁ * x₂, by aesop,
        by linear_combination⟩
  mpr := by aesop

theorem neg_one_notMem_closure_insert
    (h : ∀ x y, x ∈ P → y ∈ P → x + (1 + y) * a + 1 ≠ 0) :
    -1 ∉ closure (insert a P) := fun _ => by
  rcases (mem_closure_insert).mp
      (show -1 * (1 + a) ∈ closure (insert a P) by aesop (erase simp neg_mul))
    with ⟨x, hx, y, hy, eqn⟩
  exact h _ _ hx hy (by linear_combination - eqn)

variable {P} in
theorem neg_one_notMem_closure_insert_or_of_neg_mul_mem {x y : R} (h : -(x * y) ∈ P) :
    -1 ∉ closure (insert x P) ∨ -1 ∉ closure (insert y P) := by
  rw [mem_closure_insert]
  by_contra
  apply neg_one_notMem P
  rcases (mem_closure_insert).mp (show -1 ∈ closure (insert x P) by aesop)
    with ⟨s₁, hs₁, s₂, hs₂, eqx⟩
  rcases (mem_closure_insert).mp (show -1 ∈ closure (insert y P) by aesop)
    with ⟨t₁, ht₁, t₂, ht₂, eqy⟩
  rw [show -1 = (-(x * y)) * s₂ * t₂ + s₁ + t₁ + (s₁ * t₁) by
    linear_combination (t₁ + 1) * eqx - 1 * x * s₂ * eqy]
  aesop (config := { enableSimp := false })

/--
If `F` is a field, `P` is a preordering on `F`, and `a` is an element of `P` such that `-a ∉ P`,
then `-1` is not in the semiring generated by `P` and `a`.
-/
theorem neg_one_notMem_closure_insert_of_neg_notMem
    {F : Type*} [Field F] {P : Subsemiring F} [P.IsPreordering] {a : F} (ha : -a ∉ P) :
    -1 ∉ Subsemiring.closure (insert a P) := by
  rw [mem_closure_insert]
  rintro ⟨x, hx, y, hy, eqn⟩
  apply ha
  have : y ≠ 0 := fun _ => by aesop
  rw [show -a = x * y⁻¹ + y⁻¹ by field_simp; linear_combination eqn]
  aesop

theorem exists_le_and_mem_or_mem (x y : R) (h : -(x * y) ∈ P) :
    ∃ Q ≥ P, Q.IsPreordering ∧ (x ∈ Q ∨ y ∈ Q) := by
  rcases neg_one_notMem_closure_insert_or_of_neg_mul_mem h with hP | hP <;>
    exact ⟨_, fun _ ↦ by aesop, closure_insert hP, by aesop⟩

/- A maximal preordering on `R` is an ordering. -/
theorem _root_.Subsemiring.IsOrdering.of_maximal_isPreordering
    {O : Subsemiring R} (max : Maximal IsPreordering O) : O.IsOrdering :=
  have := max.prop
  IsPreordering.isOrdering_iff.mpr <| fun a b h => by
  rcases IsPreordering.exists_le_and_mem_or_mem _ _ _ h with ⟨O', hO'₁, hO'₂, hO'₃⟩
  aesop (add safe forward (max.le_of_ge hO'₂ hO'₁))

/- Every preordering on `R` extends to an ordering. -/
theorem exists_le_isOrdering (P : Subsemiring R) [P.IsPreordering] :
    ∃ O ≥ P, O.IsOrdering :=
  have ⟨_, _, hO⟩ : ∃ O, P ≤ O ∧ Maximal IsPreordering O := by
    refine zorn_le_nonempty₀ {P : Subsemiring R | IsPreordering P} ?_ P (by simpa)
    exact fun S hS hc Q hQ =>
      ⟨_, IsPreordering.sSup (Set.nonempty_of_mem hQ) hc.directedOn hS, CompleteLattice.le_sSup S⟩
  ⟨_, ‹_›, .of_maximal_isPreordering hO⟩

theorem exists_le_isOrdering_and_mem
    {P : Subsemiring R} [P.IsPreordering] {a : R} (h : -1 ∉ closure (insert a P)) :
    ∃ O ≥ P, O.IsOrdering ∧ a ∈ O := by
  have := closure_insert h
  rcases exists_le_isOrdering (closure (insert a P)) with ⟨O, _, _⟩
  exact ⟨O, fun _ ↦ by aesop, inferInstance, by aesop⟩

theorem exists_le_isOrdering_and_mem_or_neg_mem :
    ∃ Q ≥ P, Q.IsOrdering ∧ (a ∈ Q ∨ -a ∈ Q) := by
  rcases exists_le_and_mem_or_mem P a (-a) (by simp) with ⟨P', _, _, _⟩
  rcases exists_le_isOrdering P' with ⟨O, _, _⟩
  exact ⟨O, by order, inferInstance, by aesop⟩

theorem exists_lt_isOrdering (hp : a ∉ P) (hn : -a ∉ P) :
    ∃ Q > P, Q.IsOrdering := by
  rcases exists_le_isOrdering_and_mem_or_neg_mem P a with ⟨Q, le, hQ, mem | mem⟩ <;>
    exact ⟨Q, lt_of_le_of_ne le <| Ne.symm (ne_of_mem_of_not_mem' mem ‹_›), hQ⟩

end IsPreordering

/- A maximal ordering on `R` is precisely a maixmal preordering on `R`. -/
theorem maximal_isOrdering_iff_maximal_isPreordering {O : Subsemiring R} :
    Maximal IsOrdering O ↔ Maximal IsPreordering O where
  mp hO :=
    ⟨have := hO.prop; inferInstance, fun P hP h ↦ by
      rcases IsPreordering.exists_le_isOrdering P with ⟨O', hO', hO'₂⟩
      simpa [Maximal.eq_of_ge hO hO'₂ (by order)] using hO'⟩
  mpr hO := Maximal.mono hO (fun _ _ => inferInstance) (.of_maximal_isPreordering hO)

/- A preordering on a field `F` is maximal iff it is an ordering. -/
theorem maximal_isPreordering_iff_isOrdering {F : Type*} [Field F] {O : Subsemiring F} :
    Maximal IsPreordering O ↔ O.IsOrdering where
  mp h := .of_maximal_isPreordering h
  mpr _ := ⟨inferInstance, fun O' _ ↦ by
    simpa using (AddSubmonoid.IsSpanning.maximal_isPointed O.toAddSubmonoid).le_of_ge
      (inferInstanceAs O'.IsPointed)⟩
