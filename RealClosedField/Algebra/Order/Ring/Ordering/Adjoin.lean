/-
Copyright (c) 2024 Florent Schaffhauser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Florent Schaffhauser, Artie Khovanov
-/
import Mathlib.Order.Zorn
import RealClosedField.Algebra.Order.Ring.Ordering.Basic

/-!

Let `R` be a commutative ring, and let `P` be a preordering on `R`. If `a ∉ P`, then we can extend
`P` to a preordering containing either `a` or `-a`.
Moreover, we can always extend `P` to an ordering on `R`.

We also prove various sufficient conditions to be able to extend `P` to `a`,
and that all orderings on a field are maximal preorderings.

## References

- [*An introduction to real algebra*, T.Y. Lam][lam_1984]

-/

/-!
### Adjoining an element to a preordering
-/

variable {R : Type*} [CommRing R] (P : RingPreordering R) (a : R)

namespace Subsemiring

/-- An explicit form for the semiring generated by a preordering `P` and an element `a`. -/
def ringPreordering_adjoin : Subsemiring R where
  carrier := {z : R | ∃ x ∈ P, ∃ y ∈ P, z = x + a * y}
  zero_mem' := ⟨0, by aesop, 0, by aesop, by simp⟩
  one_mem' := ⟨1, by aesop, 0, by aesop, by simp⟩
  add_mem' := fun ha hb => by
    rcases ha, hb with ⟨⟨x₁, hx₁, y₁, hy₁, rfl⟩, ⟨x₂, hx₂, y₂, hy₂, rfl⟩⟩
    exact ⟨x₁ + x₂, by aesop, y₁ + y₂, by aesop, by linear_combination⟩
  mul_mem' := fun ha hb => by
    rcases ha, hb with ⟨⟨x₁, hx₁, y₁, hy₁, rfl⟩, ⟨x₂, hx₂, y₂, hy₂, rfl⟩⟩
    exact ⟨x₁ * x₂ + (a * a) * (y₁ * y₂), by aesop, x₁ * y₂ + y₁ * x₂, by aesop,
      by linear_combination⟩

variable {P} in
@[aesop unsafe 70% apply (rule_sets := [SetLike])]
theorem mem_ringPreordering_adjoin_of_mem {x : R} (hx : x ∈ P) :
    x ∈ ringPreordering_adjoin P a := ⟨x, by aesop, 0, by aesop, by simp⟩

@[aesop safe apply (rule_sets := [SetLike])]
theorem mem_ringPreordering_adjoin : a ∈ ringPreordering_adjoin P a :=
  ⟨0, by aesop, 1, by aesop, by simp⟩

@[aesop unsafe 50% apply (rule_sets := [SetLike])]
theorem mem_of_isSquare_ringPreordering_adjoin {x : R} (hx : IsSquare x) :
    x ∈ ringPreordering_adjoin P a :=
  by simpa using mem_ringPreordering_adjoin_of_mem a (by aesop)

theorem closure_insert_eq_ringPreordering_adjoin :
    closure (insert a P) = ringPreordering_adjoin P a :=
  closure_eq_of_le (fun _ => by aesop) (fun _ ⟨_, _, _, _, _⟩ => by aesop)

end Subsemiring

namespace RingPreordering

variable {P a} in
def adjoin (h : -1 ∉ Subsemiring.ringPreordering_adjoin P a) : RingPreordering R :=
  .mkOfSubsemiring (Subsemiring.ringPreordering_adjoin P a) (fun _ => by aesop) h

variable {P a} in
@[aesop unsafe 90% apply (rule_sets := [SetLike])]
theorem mem_adjoin_of_mem (h : -1 ∉ Subsemiring.ringPreordering_adjoin P a) {x : R} (hx : x ∈ P) :
    x ∈ adjoin h := Subsemiring.mem_ringPreordering_adjoin_of_mem a hx

variable {P a} in
theorem subset_adjoin (h : -1 ∉ Subsemiring.ringPreordering_adjoin P a) : (P : Set R) ⊆ adjoin h :=
  fun _ => by aesop

variable {P a} in
@[aesop safe apply (rule_sets := [SetLike])]
theorem mem_adjoin (h : -1 ∉ Subsemiring.ringPreordering_adjoin P a) : a ∈ adjoin h :=
  Subsemiring.mem_ringPreordering_adjoin P a

/-
## Sufficient conditions for adjoining an element
-/

variable {P} in
theorem neg_one_notMem_adjoin_or_of_neg_mul_mem {x y : R} (h : -(x * y) ∈ P) :
    -1 ∉ Subsemiring.ringPreordering_adjoin P x ∨ -1 ∉ Subsemiring.ringPreordering_adjoin P y := by
  by_contra
  apply RingPreordering.neg_one_notMem P
  have ⟨s₁, hs₁, s₂, hs₂, eqx⟩ : -1 ∈ Subsemiring.ringPreordering_adjoin P x := by aesop
  have ⟨t₁, ht₁, t₂, ht₂, eqy⟩ : -1 ∈ Subsemiring.ringPreordering_adjoin P y := by aesop
  rw [show -1 = (-(x * y)) * s₂ * t₂ + s₁ + t₁ + (s₁ * t₁) by
    linear_combination (t₁ + 1) * eqx - 1 * x * s₂ * eqy]
  aesop (config := { enableSimp := false })

theorem neg_one_notMem_adjoin_or :
    -1 ∉ Subsemiring.ringPreordering_adjoin P a ∨ -1 ∉ Subsemiring.ringPreordering_adjoin P (-a) :=
  neg_one_notMem_adjoin_or_of_neg_mul_mem (by aesop : -(a * (-a)) ∈ P)

theorem neg_one_notMem_adjoin
    (h : ∀ x y, x ∈ P → y ∈ P → x + (1 + y) * a + 1 ≠ 0) :
    -1 ∉ Subsemiring.ringPreordering_adjoin P a := fun contr => by
  have ⟨x, hx, y, hy, eqn⟩ : -1 * (1 + a) ∈ Subsemiring.ringPreordering_adjoin P a :=
    by aesop (config := { enableSimp := false })
  exact h _ _ hx hy (show x + (1 + y) * a + 1 = 0 by linear_combination -(1 * eqn))

/--
If `F` is a field, `P` is a preordering on `F`, and `a` is an element of `P` such that `-a ∉ P`,
then `-1` is not of the form `x + a * y` with `x` and `y` in `P`.
-/
theorem neg_one_notMem_ringPreordering_adjoin_of_neg_notMem
    {F : Type*} [Field F] {P : RingPreordering F} {a : F}
    (ha : -a ∉ P) : -1 ∉ Subsemiring.ringPreordering_adjoin P a := fun ⟨x, hx, y, hy, eqn⟩ =>
  ha <| by
  have : y ≠ 0 := fun _ => by aesop
  rw [show -a = x * y⁻¹ + y⁻¹ by field_simp; linear_combination eqn]
  aesop

/-!
### Existence of orderings
-/

theorem exists_le :
    ∃ Q : RingPreordering R, P ≤ Q ∧ (a ∈ Q ∨ -a ∈ Q) := by
  cases neg_one_notMem_adjoin_or P a with
  | inl h => exact ⟨adjoin h, subset_adjoin _, by aesop⟩
  | inr h => exact ⟨adjoin h, subset_adjoin _, by aesop⟩

theorem exists_lt (hp : a ∉ P) (hn : -a ∉ P) :
    ∃ Q : RingPreordering R, P < Q := by
  rcases exists_le P a with ⟨Q, le, p_mem | n_mem⟩
  · exact ⟨Q, lt_of_le_of_ne le <| Ne.symm (ne_of_mem_of_not_mem' p_mem hp)⟩
  · exact ⟨Q, lt_of_le_of_ne le <| Ne.symm (ne_of_mem_of_not_mem' n_mem hn)⟩

/- A maximal preordering on `R` is an ordering. -/
theorem isOrdering_of_maximal {O : RingPreordering R} (max : IsMax O) :
    IsOrdering O := isOrdering_iff.mpr <| fun a b h => by
  cases neg_one_notMem_adjoin_or_of_neg_mul_mem h with
  | inl h => exact Or.inl <| max (subset_adjoin h) (mem_adjoin h)
  | inr h => exact Or.inr <| max (subset_adjoin h) (mem_adjoin h)

/- Every preordering on `R` extends to an ordering. -/
theorem exists_le_isOrdering :
    ∃ O : RingPreordering R, P ≤ O ∧ IsOrdering O := by
  have ⟨_, _, hO⟩ : ∃ O, P ≤ O ∧ IsMax O := by
    refine zorn_le_nonempty_Ici₀ _ (fun _ _ hc _ hQ => ?_) _ le_rfl
    simp_all [← bddAbove_def, nonempty_chain_bddAbove (Set.nonempty_of_mem hQ) hc]
  exact ⟨_, by assumption, isOrdering_of_maximal hO⟩

/- An ordering on `R` is maximal among preorderings iff it is maximal among orderings. -/
theorem maximal_iff_maximal_isOrdering {O : RingPreordering R} [IsOrdering O] :
    IsMax O ↔ Maximal IsOrdering O :=
  ⟨fun h => Maximal.mono (by simpa using h) (fun _ _ => trivial) inferInstance,
   fun hO P le₁ => by aesop (add safe forward exists_le_isOrdering,
                                 safe forward le_trans,
                                 safe forward Maximal.eq_of_ge)⟩

/-!
### Comparison of orderings
-/

theorem mem_support_of_ge_of_notMem [HasMemOrNegMem P] (Q : RingPreordering R) (h : P ≤ Q)
    (ha : a ∈ Q) (haP : a ∉ P) : a ∈ supportAddSubgroup Q := by aesop

theorem eq_of_le_of_supportAddSubgroup_eq_bot {P} [HasMemOrNegMem P] {Q : RingPreordering R}
    (hSupp : supportAddSubgroup Q = ⊥) (h : P ≤ Q) : P = Q := by
  by_contra h2
  have ⟨x, hx, hx2⟩ : ∃ x, x ∈ Q ∧ x ∉ P :=
    Set.exists_of_ssubset <| lt_of_le_of_ne h (by simpa using h2)
  have : 0 ∈ P := by aesop
  have : -x ∈ Q := by aesop
  apply_fun (x ∈ ·) at hSupp
  aesop

theorem eq_of_le {F : Type*} [Field F] {P Q : RingPreordering F} [IsOrdering P]
    (h : P ≤ Q) : P = Q := eq_of_le_of_supportAddSubgroup_eq_bot (by simp) h

/- A preordering on a field `F` is maximal iff it is an ordering. -/
theorem maximal_iff_hasMemOrNegMem {F : Type*} [Field F] {O : RingPreordering F} :
    IsMax O ↔ IsOrdering O :=
  ⟨fun h => have := isOrdering_of_maximal h; inferInstance,
   fun _ _ le => le_of_eq (eq_of_le le).symm⟩
